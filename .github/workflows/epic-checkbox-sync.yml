name: Sync EPIC checkboxes (close, reopen & route to Project)

on:
  issues:
    types: [edited]

env:
  ORG: ""                           # se vazio, usa o owner do repo
  PROJECT_NUMBER: "13"               # número do Project v2
  PROJECT_TITLE: "TCC - Locadora de Automoveis"  # opcional: usado só para logs
  MAP_CLOSED_JSON: >
    { "default": "Prontos" }
  MAP_OPEN_JSON: >
    { "default": "Em Progresso" }
  ADD_IF_MISSING: "true"

jobs:
  sync:
    if: startsWith(github.event.issue.title, 'EPIC:') && github.event.changes.body != null
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    concurrency:
      group: epic-sync-${{ github.event.issue.number }}
      cancel-in-progress: false

    steps:
      - name: Close/Reopen & Move in Project
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.WORKFLOW_PAT }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            const before = context.payload.changes?.body?.from || '';
            const after  = context.payload.issue.body || '';

            const getChecked = (s) => {
              const re = /-\s*\[[xX]\]\s*#(\d+)/g;
              return new Set([...s.matchAll(re)].map(m => Number(m[1])));
            };

            const prev = getChecked(before);
            const curr = getChecked(after);

            const toClose = [...curr].filter(n => !prev.has(n));
            const toOpen  = [...prev].filter(n => !curr.has(n));
            const uniq = (arr) => [...new Set(arr)];

            const closedNow  = [];
            const reopenedNow = [];

            // 1) fechar
            for (const num of uniq(toClose)) {
              try {
                const { data } = await github.rest.issues.get({ owner, repo, issue_number: num });
                if (data.pull_request) { core.info(`#${num} é PR; ignore`); continue; }
                if (data.state !== 'closed') {
                  await github.rest.issues.update({ owner, repo, issue_number: num, state: 'closed' });
                }
                closedNow.push({ number: num, labels: (data.labels||[]).map(l => typeof l==='string'? l : l.name) });
                core.info(`Closed #${num}`);
              } catch (e) { core.warning(`Falha ao fechar #${num}: ${e.message}`); }
            }

            // 2) reabrir
            for (const num of uniq(toOpen)) {
              try {
                const { data } = await github.rest.issues.get({ owner, repo, issue_number: num });
                if (data.pull_request) { core.info(`#${num} é PR; ignore`); continue; }
                if (data.state !== 'open') {
                  await github.rest.issues.update({ owner, repo, issue_number: num, state: 'open' });
                }
                reopenedNow.push({ number: num, labels: (data.labels||[]).map(l => typeof l==='string'? l : l.name) });
                core.info(`Reopened #${num}`);
              } catch (e) { core.warning(`Falha ao reabrir #${num}: ${e.message}`); }
            }

            // 3) localizar Project v2 de forma robusta
            const LOGIN = (process.env.ORG || '').trim() || owner;
            const PROJ_NUM = parseInt(process.env.PROJECT_NUMBER || '0', 10);
            const PROJ_TITLE = (process.env.PROJECT_TITLE || '').trim();
            const ADD_IF_MISSING = process.env.ADD_IF_MISSING === "true";
            const MAP_CLOSED = JSON.parse(process.env.MAP_CLOSED_JSON || "{}");
            const MAP_OPEN   = JSON.parse(process.env.MAP_OPEN_JSON   || "{}");

            core.info(`Lookup Project: login='${LOGIN}' number=${PROJ_NUM} title='${PROJ_TITLE || '(n/a)'}'`);

            // tenta identificar se LOGIN é org
            let isOrg = false;
            try {
              await github.rest.orgs.get({ org: LOGIN });
              isOrg = true;
              core.info(`'${LOGIN}' é uma organização.`);
            } catch { core.info(`'${LOGIN}' não parece org; tentando como usuário.`); }

            // tenta org.projectV2(number)
            const orgQuery = `
              query($login:String!, $number:Int!) {
                organization(login:$login) {
                  projectV2(number:$number) { id title }
                }
              }`;
            // tenta user.projectV2(number)
            const userQuery = `
              query($login:String!, $number:Int!) {
                user(login:$login) {
                  projectV2(number:$number) { id title }
                }
              }`;

            let project = null;
            try {
              if (isOrg) {
                const r = await github.graphql(orgQuery, { login: LOGIN, number: PROJ_NUM });
                project = r.organization?.projectV2 ?? null;
              }
              if (!project) {
                const r2 = await github.graphql(userQuery, { login: LOGIN, number: PROJ_NUM });
                project = r2.user?.projectV2 ?? null;
              }
            } catch (e) {
              core.warning(`Falha no lookup direto por number: ${e.message}`);
            }

            if (!project) {
              core.warning(`Project #${PROJ_NUM} não resolvido; conferindo se o repo está linkado e visível ao token.`);
              core.warning(`→ Confirme em Repository → Projects → "Link a project" que '${PROJ_TITLE || '(teu project)'}' está linkado.`);
              core.warning(`→ Se a org restringe acesso, use um PAT no github-script.`);
              return;
            }

            core.info(`Project encontrado: ${project.title}`);

            // carregar campo Status e opções
            const fieldsQuery = `
              query($id:ID!) {
                node(id:$id) {
                  ... on ProjectV2 {
                    id title
                    fields(first:50) {
                      nodes {
                        ... on ProjectV2SingleSelectField {
                          id name
                          options { id name }
                        }
                      }
                    }
                  }
                }
              }`;
            const fr = await github.graphql(fieldsQuery, { id: project.id });
            const projNode = fr.node;
            const statusField = projNode.fields.nodes.find(f => f?.name === "Status");
            if (!statusField) { core.warning(`Campo 'Status' não encontrado em '${projNode.title}'`); return; }
            const optionIdByName = (name) => statusField.options.find(o => o.name === name)?.id;

            const issueItemQuery = `
              query($owner:String!, $repo:String!, $num:Int!) {
                repository(owner:$owner, name:$repo) {
                  issue(number:$num) {
                    id
                    projectItems(first:50) { nodes { id project { ... on ProjectV2 { id } } } }
                  }
                }
              }`;
            const addItemMutation = `
              mutation($projectId:ID!, $contentId:ID!) {
                addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                  item { id }
                }
              }`;
            const updateMutation = `
              mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optionId:String!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                  value:{ singleSelectOptionId:$optionId }
                }) { clientMutationId }
              }`;

            const setStatus = async (issueNumber, statusName) => {
              if (!statusName) return;
              const optId = optionIdByName(statusName);
              if (!optId) { core.warning(`Opção '${statusName}' não existe em Status`); return; }

              const res = await github.graphql(issueItemQuery, { owner, repo, num: issueNumber });
              const issueId = res.repository?.issue?.id;
              let item = res.repository?.issue?.projectItems?.nodes?.find(n => n.project?.id === project.id);
              if (!item) {
                if (!ADD_IF_MISSING) { core.info(`#${issueNumber} não está no Project; ignorando`); return; }
                const added = await github.graphql(addItemMutation, { projectId: project.id, contentId: issueId });
                item = added.addProjectV2ItemById.item;
                core.info(`#${issueNumber} adicionado ao Project '${projNode.title}'`);
              }

              await github.graphql(updateMutation, {
                projectId: project.id,
                itemId: item.id,
                fieldId: statusField.id,
                optionId: optId
              });
              core.info(`Status de #${issueNumber} → '${statusName}' atualizado.`);
            };

            const pickStatus = (labels, map) => {
              for (const l of labels || []) if (map[l]) return map[l];
              return map.default;
            };

            for (const it of closedNow)  { await setStatus(it.number, pickStatus(it.labels, MAP_CLOSED)); }
            for (const it of reopenedNow){ await setStatus(it.number, pickStatus(it.labels, MAP_OPEN)); }
